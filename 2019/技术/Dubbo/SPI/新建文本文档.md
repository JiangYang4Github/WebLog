

### Java SPI

SPI机制（Service Provider Interface)其实源自服务提供者框架（Service Provider Framework，参考【EffectiveJava】page6)，是一种将服务接口与服务实现分离以达到解耦、大大提升了程序可扩展性的机制。引入服务提供者就是引入了spi接口的实现者，通过本地的注册发现获取到具体的实现类，轻松可插拔。

Java SPI 实际上是“基于接口的编程＋策略模式＋配置文件”组合实现的动态加载机制。

1. 定义一个接口。
2. 编写此接口的实现类。
3. 在 src/main/resources/ 下建立 /META-INF/services 目录， 新增一个以接口命名的文件。
4. 文件中写要使用的实现类，每行一个类。
5. 使用 ServiceLoader 来加载配置文件中指定的实现。

代码结构如下：

```java
+--src
|   +--com
|       +--test
|           +--spi
|               --RunService
|               --RunServiceImpl
```



```java
+--src
|   +--main
|        +--resources
|            +--META-INF
|                +--services
|                    - com.test.spi.RunService
```

使用方式如下：

```java
public class SPIMain {
    public static void main(String[] args) {
        ServiceLoader<RunService> runService = ServiceLoader.load(RunService.class);
        for (runService r : runService) {
            r.doRun();
        }
    }
}
```

dubbo中重新实现了一套SPI机制，做了一些优化和改进，比如拓展类被调用得到时候再加载，自动包装机制，加载出错的异常通知等。

### SPI注解说明

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface SPI {
    String value() default "";
}
```

修饰在 class 上面，在Dubbo中都是在修饰接口，制定接口的默认实现类，如下图，我们可以看到声明了使用javasist作为代理类的实现方式。

```
@SPI("javassist")
public interface ProxyFactory {
    ...
}
```

### Adaptive注解说明

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Adaptive {    
    String[] value() default {};
}
```

dubbo spi机制，即定义了各种实现类的配置文件，再根据具体的key寻找具体实现类的过程，中间经历各种放入缓存操作，读取文件及反射，达到不同实现的扩展。而Adaptive注解注在类上，代表已知实现类，优先使用，注在接口的方法上，代表会生成一个$Adaptive适配类。